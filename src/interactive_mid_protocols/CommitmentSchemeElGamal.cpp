#include "../../include/interactive_mid_protocols/CommitmentSchemeElGamal.hpp"

/**
* Sets the given parameters and execute the preprocess phase of the scheme.
* @param channel
* @param dlog
* @param elGamal
* @param random
* @throws SecurityLevelException if the given dlog is not DDH secure
* @throws InvalidDlogGroupException if the given dlog is not valid.
* @throws IOException if there was a problem in the communication
*/
void CmtElGamalCommitterCore::doConstruct(shared_ptr<CommParty> channel, shared_ptr<DlogGroup> dlog, shared_ptr<ElGamalOnGroupElementEnc> elGamal) {
	//The underlying dlog group must be DDH secure.
	auto ddh = dynamic_pointer_cast<DDH>(dlog);
	if (ddh == NULL) {
		throw SecurityLevelException("DlogGroup should have DDH security level");
	}
	if (!dlog->validateGroup())
		throw InvalidDlogGroupException("");

	this->channel = channel;
	this->dlog = dlog;
	this->random = get_seeded_random();
	qMinusOne = dlog->getOrder() - 1;
	this->elGamal = elGamal;
	preProcess();
}

/**
* The pre-process is performed once within the construction of this object.
* If the user needs to generate new pre-process values then it needs to disregard
* this instance and create a new one.
* Runs the following lines from the pseudo code:
* "SAMPLE random values  a<- Zq
*	COMPUTE h = g^a"
* @throws IOException
*/
void CmtElGamalCommitterCore::preProcess() {
	//Instead of sample a and compute h, generate public and private keys directly.

	auto pair = elGamal->generateKey();
	//We keep both keys, the private key is used to prove knowledge of this commitment
	//but is not used by the encryption object.

	publicKey = dynamic_pointer_cast<ElGamalPublicKey>(pair.first);
	privateKey = dynamic_pointer_cast<ElGamalPrivateKey>(pair.second);
	elGamal->setKey(publicKey);

	//Send the public key to the receiver since throughout this connection the same key will be used used for all the commitments.
	channel->writeWithSize(publicKey->generateSendableData()->toString());
}

/**
* Computes the commitment object of the commitment scheme. <p>
* Pseudo code:<p>
* "SAMPLE random values  r <- Zq <p>
*	COMPUTE u = g^r and v = h^r * x". <p>
* @return the created commitment.
*/
shared_ptr<CmtCCommitmentMsg> CmtElGamalCommitterCore::generateCommitmentMsg(shared_ptr<CmtCommitValue> input, long id) {
	//Sample random r <-Zq.
	biginteger r = getRandomInRange(0, qMinusOne, random);
	//Compute u = g^r and v = h^r * x.
	//This is actually the encryption of x.
	auto c = elGamal->encrypt(input->convertToPlaintext(), r);
	//keep the committed value in the map together with its ID.
	commitmentMap[id] = make_shared<CmtElGamalCommitmentPhaseValues>(make_shared<BigIntegerRandomValue>(r), input, c);
	return make_shared<CmtElGamalCommitmentMessage>(dynamic_pointer_cast<ElGamalOnGrElSendableData>(c->generateSendableData()), id);
}

shared_ptr<CmtCDecommitmentMessage> CmtElGamalCommitterCore::generateDecommitmentMsg(long id)  {

	//fetch the commitment according to the requested ID
	auto values = commitmentMap[id];
	return make_shared<CmtElGamalDecommitmentMessage>(values->getX()->toString(), dynamic_pointer_cast<BigIntegerRandomValue>(values->getR()));
}

vector<shared_ptr<void>> CmtElGamalCommitterCore::getPreProcessValues() {
	vector<shared_ptr<void>> values;
	values.push_back(publicKey);
	values.push_back(privateKey);
	return values;
}

shared_ptr<CmtCCommitmentMsg> CmtElGamalOnGroupElementCommitter::generateCommitmentMsg(shared_ptr<CmtCommitValue> input, long id)  {
	auto in = dynamic_pointer_cast<CmtGroupElementCommitValue>(input);
	if (in == NULL)
		throw invalid_argument("The input must be of type CmtGroupElementCommitValue");
	return CmtElGamalCommitterCore::generateCommitmentMsg(input, id);
}

/**
* This function converts the given commit value to a byte array.
* @param value
* @return the generated bytes.
*/
vector<byte> CmtElGamalOnGroupElementCommitter::generateBytesFromCommitValue(CmtCommitValue* value) {
	auto val = dynamic_cast<CmtGroupElementCommitValue*>(value);
	if (val == NULL)
		throw invalid_argument("The given value must be of type CmtGroupElementCommitValue");
	return dlog->mapAnyGroupElementToByteArray(static_pointer_cast<GroupElement>(val->getX()).get());
}

/**
* Sets the given parameters and execute the preprocess phase of the scheme.
* @param channel
* @param dlog
* @param elGamal
*/
void CmtElGamalReceiverCore::doConstruct(shared_ptr<CommParty> channel, shared_ptr<DlogGroup> dlog, shared_ptr<ElGamalOnGroupElementEnc> elGamal) {
	//The underlying dlog group must be DDH secure.
	auto ddh = dynamic_pointer_cast<DDH>(dlog);
	if (ddh == NULL) {
		throw SecurityLevelException("DlogGroup should have DDH security level");
	}
	if (!dlog->validateGroup())
		throw InvalidDlogGroupException("");

	this->channel = channel;
	this->dlog = dlog;
	this->elGamal = elGamal;
	preProcess();
	elGamal->setKey(publicKey);
}

/**
* The pre-process is performed once within the construction of this object.
* If the user needs to generate new pre-process values then it needs to disregard
* this instance and create a new one.
*/
void CmtElGamalReceiverCore::preProcess() {
	ElGamalPublicKeySendableData publicKeySendableData(dlog->getGenerator()->generateSendableData());
	// read encoded CmtPedersenCommitmentMessage from channel
	vector<byte> raw_msg; // by the end of the scope - no need to hold it anymore - already decoded and copied
	channel->readWithSizeIntoVector(raw_msg);
	publicKeySendableData.initFromByteVector(raw_msg);
	publicKey = dynamic_pointer_cast<ElGamalPublicKey>(elGamal->reconstructPublicKey(&publicKeySendableData));
	//Set the public key from now on until the end of usage of this instance.
	auto h = publicKey->getH();
	if (!dlog->isMember(h.get()))
		throw CheatAttemptException("h element is not a member of the current DlogGroup");
}

/**
* Runs the commit phase of the commitment scheme.<p>
* Pseudo code:<p>
* "WAIT for a value c<p>
*	STORE c".
* @return the output of the commit phase.
*/
shared_ptr<CmtRCommitPhaseOutput> CmtElGamalReceiverCore::receiveCommitment()  {
	// create an empty CmtPedersenCommitmentMessage 
	auto elementSendable1 = dlog->getGenerator()->generateSendableData();
	auto elementSendable2 = dlog->getGenerator()->generateSendableData();
	auto msg = make_shared<CmtElGamalCommitmentMessage>(make_shared<ElGamalOnGrElSendableData>(elementSendable1, elementSendable2));
	
	// read encoded CmtPedersenCommitmentMessage from channel
	vector<byte> raw_msg; // by the end of the scope - no need to hold it anymore - already decoded and copied
	channel->readWithSizeIntoVector(raw_msg);
	// init the empy CmtPedersenCommitmentMessage using the encdoed data
	msg->initFromByteVector(raw_msg);
	commitmentMap[msg->getId()] = msg;
	return make_shared<CmtRBasicCommitPhaseOutput>(msg->getId());
}

/**
* Runs the decommit phase of the commitment scheme.<p>
* Pseudo code:<p>
* "WAIT for (r, x)  from C<p>
*	Let c = (h,u,v); if not of this format, output REJ<p>
*	IF NOT<p>
*		u=g^r <p>
*		v = h^r * x<p>
*		x in G<p>
*		OUTPUT REJ<p>
*	ELSE<p>
*	    OUTPUT ACC and value x"
* @param id
* @return the committed value if the decommit succeeded; null, otherwise.
*/
shared_ptr<CmtCommitValue> CmtElGamalReceiverCore::receiveDecommitment(long id) {
	vector<byte> raw_msg;
	channel->readWithSizeIntoVector(raw_msg);
	auto msg = make_shared<CmtElGamalDecommitmentMessage>();
	msg->initFromByteVector(raw_msg); 
	auto receivedCommitment = commitmentMap[id];
	return verifyDecommitment(receivedCommitment.get(), msg.get());
}

vector<shared_ptr<void>> CmtElGamalReceiverCore::getPreProcessedValues() {
	vector<shared_ptr<void>> keys;
	keys.push_back(publicKey);
	return keys;
}

/**
* Proccesses the decommitment phase.<p>
* "IF NOT<p>
*		u=g^r <p>
*		v = h^r * x<p>
*		x in G<p>
*		OUTPUT REJ<p>
*	ELSE<p>
*	    OUTPUT ACC and value x"<p>
* @param id the id of the commitment.
* @param msg the receiver message from the committer
* @return the committed value if the decommit succeeded; null, otherwise.
*/
shared_ptr<CmtCommitValue> CmtElGamalOnGroupElementReceiver::verifyDecommitment(CmtCCommitmentMsg* commitmentMsg,
	CmtCDecommitmentMessage* decommitmentMsg) {
	auto decom = dynamic_cast<CmtElGamalDecommitmentMessage*>(decommitmentMsg);
	auto com = dynamic_cast<CmtElGamalCommitmentMessage*>(commitmentMsg);
	if (decom == NULL) {
		throw invalid_argument("decommitmentMsg should be an instance of CmtElGamalDecommitmentMessage");
	}
	if (com == NULL) {
		throw invalid_argument("commitmentMsg should be an instance of CmtElGamalCommitmentMessage");
	}
	auto sendable = dlog->getGenerator()->generateSendableData();
	sendable->initFromString(decom->getX());
	auto xEl = dlog->reconstructElement(true, sendable.get());
	
	//First check if x is a group element in the current Dlog Group, if not return null meaning rejection:
	if (!dlog->isMember(xEl.get()))
		return NULL;

	auto commitment = static_pointer_cast<ElGamalOnGrElSendableData>(com->getCommitment());
	auto r = dynamic_pointer_cast<BigIntegerRandomValue>(decom->getR())->getR();
	//Fetch received commitment according to ID
	if (commitment == NULL)
		throw invalid_argument("commitment value is not an instance of ElGamalOnGrElSendableData");

	auto u = dlog->reconstructElement(true, commitment->getCipher1().get());
	auto v = dlog->reconstructElement(true, commitment->getCipher2().get());
	auto gToR = dlog->exponentiate(dlog->getGenerator().get(), r);
	auto hToR = dlog->exponentiate(publicKey->getH().get(), r);

	if ((*u == *gToR) && (*v == *dlog->multiplyGroupElements(hToR.get(), xEl.get())))
		return make_shared<CmtGroupElementCommitValue>(xEl);
	return NULL;
}

/**
* This function converts the given commit value to a byte array.
* @param value
* @return the generated bytes.
*/
vector<byte> CmtElGamalOnGroupElementReceiver::generateBytesFromCommitValue(CmtCommitValue* value) {
	auto tmp = dynamic_cast<CmtGroupElementCommitValue*>(value);
	if (tmp == NULL)
		throw invalid_argument("The given value must be of type CmtGroupElementCommitValue");
	return dlog->mapAnyGroupElementToByteArray(static_cast<GroupElement*>(tmp->getX().get()));
}